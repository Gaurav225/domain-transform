%\section{Your Proposed Method}\label{sec:method}
\section{Optimizing Domain Transform}
We started with the matlab code provided on the homepage\footnote{\url{http://www.inf.ufrgs.br/~eslgastal/DomainTransform/}} of the authors~\cite{GastalOliveira2011DomainTransform} and ported the code to C++. 
\subsection{Optimization Steps}
\subsubsection{Basic version}
In order to achieve the biggest optimisation potential the matrices have been wrapped in a simple struct (listing \ref{code:matrix_struct}).
\begin{lstlisting}[caption=Matrix struct,label=code:matrix_struct]
struct Mat2
{
    uint width, height;
    float3* data; // size: width*height
};
\end{lstlisting}
In order to preserve accuracy all images are stored in a \lstinline{float3} struct. Which uses $3\times 4 = 12$ bytes per pixel. Hence a $1$M pixel image is stored in $3\times 4\times 10^6$\ B $=12$\ MB.
The algorithm starts by precomputing $dIdx$ and $dIdy$ the differential of the image in both $x$ and $y$ direction. Then the prefix sum of both $dIdx$ and $dIdY^T$ is compute. 
During the filtering step we (listing \ref{code:filterstep}) compute \lstinline{computeBound} and \lstinline{boxFilter} twice. For each iteration step we transpose the images.
\begin{lstlisting}[caption=Filterstep,label=code:filterstep]
for (i=0; i<iterations; i++) {
    bounds = computeBound(img, dIdX, r);
    img = boxFilter(img, bounds);
    img = transpose(img);
    bounds = computeBound(img, dIdY, r);
    img = boxFilter(img, dIdY, bounds);
    img = transpose(img);
}
\end{lstlisting}
The \lstinline{computeBound} step computes the one dimensional bound for each pixel for the box filter step. The bound is dependant on a user defined radius $r$. 
During the box filter step the prefix sum of the image in the $x$ direction is precomputed with a separate function. During the box filter step the box filter makes use of the previously precomputed prefix sum and bounds to compute the filtered value for each pixel (listing \ref{code:boxfilter}).
\begin{lstlisting}[caption=Boxfilter step, label=code:boxfilter]
void boxfilter(img, bounds) {
    psum = prefixsum(img);
    for (i = 0; i < H; i++) {
        for (j = 0; j < W; j++) {
            l = lowerBound(i,j);
            r = upperBound(i,j);
            delta = r - l;
            img(i,j) = psum(l)-psum(r);
            img(i,j) = img(i,j)/delta;
        }
    }
}
\end{lstlisting}
\subsubsection{Blocked Transpose}
With benchmarking the initial version we recognised that the transpose function was responsible for most of our computation time. Hence we blocked the transpose (listing \ref{code:blocked_transpose}).
\begin{lstlisting}[caption=Transpose block, label=code:blocked_transpose]
for (yo=0; yo<Hmod; yo+=BLOCK)
  for (xo=0; xo<Wmod; xo+=BLOCK)
    for (uint y=yo; y<yo+BLOCK; y++)
      for (uint x=xo; x<xo+BLOCK; x++)
        uint idx = y*W + x;
        uint idxT = x*H + y;
        out.data[idxT] = in.data[idx];
    xo = Wmod;
    for (uint y=yo; y<yo+BLOCK; y++)
      for (uint x=xo; x<W; x++)
        uint idx = y*W + x;
        uint idxT = x*H + y;
        out.data[idxT] = in.data[idx];
// Handle bottom row and bottom rightmost block
\end{lstlisting}
\subsubsection{Inlining Bound Computation}
In order for compiler to optimise the the code we inlined the bound computation.
\begin{lstlisting}[caption=Inlining of the bound computation, label=code:inlining]
void boxfilter(img, dx, boxR) {
    psum = prefixsum(img);
    for (i=0; i<H; i++)
    {
        posL = 0;
        posR = 0;
        for (j=0; j<W; j++)
        {
            // Bound computation
            dtL = dx(i,j) - boxR;
            dtR = dx(i,j) + boxR;
            while (dx(i,posL) < dtL 
                    && posL < W-1)
                posL++;
            while (posR < W && 
                   dx(i,posR < dtR )
                posR++;
            // Boxfilter step
        }
    }
\end{lstlisting}
\subsubsection{Recombination}
The inlining allowed us to inline the prefix sum into the boxfilter bound computation step (listing \ref{code:recombination}).
\begin{lstlisting}[caption=Recombination, label=code:recombination]
    while (dx(i,posL) < dtL 
            && posL < W-1)
        sum -= imgRow[posL];
        posL++;

    while (posR < W && 
           dx(i,posR < dtR )
        sum  += imgRow[posR];
        posR++;
    // Boxfilter step
    invD = 1.0f /(posR-posL);
    img(i,j) = sum * invD;
\end{lstlisting}
\subsubsection{Write transpose}
By directly storing the data transposed with were able to increase performance and reduce the number of transpose functions needed to be computed. We note that 

\subsection{Failed optimization attempts}

\fixme{Rewrite}
\subsubsection{Precomputation} Division precomputation did not make any difference.

\subsubsection{Changing floats to \dots}

\fixme{Write}

\subsubsection{Blocking}

We tried to block the computation for spatial locality for the output matrix which didn't give any improvement (actually made it worse).

\subsubsection{Instruction interleaving}

We tried to combine the while loops that compute the borders for the filter, so that independent computation would fill the pipeline. This did not give any performance improvement, perhaps because of the fact that the combined loop still had a conditional statement for both filter borders which we cannot eradicate.

\subsubsection{Reshuffling of data}

Most of the versions we implemented work on the interleaved colour arrays, storing colours as $rgbrgb\dots$. We attempted to reshuffle the data to three separate arrays, each containing one colour, which didn't bring any performance improvement. 

We transpose 3 different arrays which is slow. Or we might write transposed, but then we'd access 3 arrays at a stride which would mess the cache up anyway.

%\\
%\fixme{Write.}
%\comment{
%Now comes the ``beef'' of the paper, where you explain what you
%did. Again, organize it in paragraphs with titles. As in every section
%you start with a very brief overview of the section.
%
%For this class, explain all the optimizations you performed. This mean, you first very briefly
%explain the baseline implementation, then go through locality and other optimizations, and finally SSE (every project will be slightly different of course). 
%Show or mention relevant analysis or assumptions. A few examples: 
%1) Profiling may lead you to optimize one part first; 
%2) bandwidth plus data transfer analysis may show that it is memory bound; 
%3) it may be too hard to implement the algorithm in full generality: make assumptions and state them 
%(e.g., we assume $n$ is divisible by 4; or, we consider only one type of input image); 
%4) explain how certain data accesses have poor locality. Generally, any type of analysis adds value to your work.
%
%As important as the final results is to show that you took a structured, organized approach to the optimization and that you explain why you did what you did.
%
%Mention and cite any external resources including library or other code.
%
%Good visuals or even brief code snippets to illustrate what you did are good. Pasting large amounts of code to fill the space is not good.
%}